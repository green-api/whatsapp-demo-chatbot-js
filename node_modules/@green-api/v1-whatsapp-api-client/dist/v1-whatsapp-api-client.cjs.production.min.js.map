{"version":3,"file":"v1-whatsapp-api-client.cjs.production.min.js","sources":["../src/Validations.ts","../src/api.ts","../src/v1-types.ts","../src/messages.ts","../src/media.ts","../src/broadcasts.ts","../src/notifications.ts","../src/index.ts"],"sourcesContent":["export const assertNumber = (val : any, errorMsg: string) => {\r\n    if (val && isNumeric(val)) {\r\n        return Number.parseInt(val)\r\n    } else {\r\n        throw new Error(errorMsg)\r\n    }\r\n}\r\n\r\nexport const assertNumeric = (val : any, errorMsg: string) => {\r\n    if (val && isNumeric(val)) {\r\n        return val\r\n    } else {\r\n        throw new Error(errorMsg)\r\n    }\r\n}\r\n\r\nexport const assertApiToken = (val : any) => {\r\n    if (!val) {\r\n        throw new Error(\"auth token not defined\")\r\n    } else {\r\n        return val\r\n    }\r\n}\r\n\r\nexport const assertNotNull = (val : any, errorMsg: string) => {\r\n    if (val) {\r\n        return val\r\n    } else {\r\n        const err = new Error(errorMsg)\r\n        throw err;\r\n    }\r\n}\r\n\r\nexport const assertObjectNotEmpty = (obj: Object, errorMsg: string) => {\r\n    if (isObjectEmpty(obj)) {\r\n        const err = new Error(errorMsg)\r\n        throw err;\r\n    } else {\r\n        return obj\r\n    }\r\n}\r\n\r\nexport const isObjectEmpty = (obj: Object) => {\r\n    return (Object.keys(obj).length === 0 && obj.constructor === Object)\r\n}\r\n\r\nexport const assertPhone = (val : string) => {\r\n    return assertNumeric(val, 'phone number has incorect format')\r\n}\r\n\r\n\r\nfunction isNumeric(value: any) {\r\n    return /^-{0,1}\\d+$/.test(value);\r\n}\r\n\r\n","\r\nimport axios, { AxiosRequestConfig } from 'axios'\r\nimport { assertApiToken } from './Validations';\r\n\r\nexport interface Options {\r\n    apiRoot: string,\r\n    mediaRoot: string,\r\n} \r\n\r\nconst DEFAULT_OPTIONS = {\r\n    apiRoot: 'https://api.green-api.com/v1',\r\n    mediaRoot: 'https://media.green-api.com/v1'\r\n}\r\n\r\nexport default class Api {\r\n\r\n    private readonly options: Options\r\n    private DEFAULT_AXIOS_CFG : AxiosRequestConfig =  {\r\n        headers: {\r\n            'Authorization': 'Bearer ' + this.token\r\n        }\r\n    }\r\n    \r\n    constructor(readonly token : string,  options?: Partial<Options>) {\r\n        this.options = {\r\n            ...DEFAULT_OPTIONS,\r\n            ...options,\r\n        }\r\n        assertApiToken(token)\r\n    }\r\n\r\n    async get(url: string) : Promise<any> {\r\n        const response = await axios.get(`${this.options.apiRoot}/${url}`, this.DEFAULT_AXIOS_CFG)\r\n        try {\r\n            return response.data\r\n        } catch (ex) {\r\n            this.processError(ex)\r\n        }\r\n    } \r\n\r\n    async delete(url: string) : Promise<any> {\r\n        const response = await axios.delete(`${this.options.apiRoot}/${url}`, this.DEFAULT_AXIOS_CFG)\r\n        try {\r\n            return response.data\r\n        } catch (ex) {\r\n            this.processError(ex)\r\n        }\r\n    } \r\n\r\n    async post(url: string, data : any) : Promise<any> {\r\n        try {\r\n            const response = await axios.post(`${this.options.apiRoot}/${url}`, data, this.DEFAULT_AXIOS_CFG)\r\n            return response.data\r\n        } catch(ex) {\r\n            this.processError(ex)\r\n        }\r\n    }\r\n\r\n    async postMedia(url: string, data : Buffer, ext: string) : Promise<any> {\r\n        try {\r\n            const config : AxiosRequestConfig = {\r\n                method: 'post',\r\n                url: `${this.options.mediaRoot}/${url}`,\r\n                headers: { \r\n                    'X-Gr-File-Extension': ext, \r\n                    'Authorization': this.DEFAULT_AXIOS_CFG.headers['Authorization'], \r\n                    'Content-Type': 'text/plain'\r\n                },\r\n                data : data\r\n            };\r\n            const response = await axios(config)\r\n            return response.data;\r\n        } catch (ex) {\r\n            this.processError(ex)\r\n        }\r\n    }\r\n\r\n    private processError(ex: any) {\r\n        if (ex.isAxiosError && ex.response && ex.response.data) {\r\n            throw new Error(JSON.stringify(ex.response.data))\r\n        } else {\r\n            throw ex\r\n        }\r\n    }\r\n}","\r\nexport namespace V1 {\r\n    export interface MessageResponse {\r\n        messages: [\r\n            {\r\n                id: string\r\n            }\r\n        ],\r\n        meta: Meta\r\n    }\r\n    export interface MediaResponse {\r\n        media: [\r\n            {\r\n                id: string\r\n            }\r\n        ],\r\n        meta: Meta\r\n    }\r\n    export enum RecipientTypes {\r\n        Individual = 'individual',\r\n        Group = 'group'\r\n    }\r\n\r\n    export interface NotificationResponse {\r\n        receipt: number,\r\n        notifications: InboundMessage[]\r\n    }\r\n\r\n}\r\n\r\ninterface Meta {\r\n    \"api_status\": \"stable\",\r\n    \"version\": \"2.0.1\"\r\n}\r\n\r\ninterface NotificationEntitiy {\r\n    type: string\r\n    account: Account,\r\n}\r\n\r\ninterface InboundMessage extends NotificationEntitiy {\r\n    type: \"inbound_message\",\r\n    messages: MessageEntity[],\r\n    contacts: [\r\n        {\r\n            profile: {\r\n                name: string\r\n            },\r\n            wa_id: string\r\n        }\r\n    ]\r\n}\r\n\r\ninterface Account {\r\n    id: string,\r\n    wa_id: string\r\n}\r\n\r\ninterface MessageEntity {\r\n    from: string\r\n    id: string\r\n    timestamp: string\r\n    type: \"text | image | video | voice | document | contacts | location\",\r\n    text?: Text,\r\n    image?: Image,\r\n    video?: Video,\r\n    voice?: Voice,\r\n    document?: Document,\r\n    contacts?: Contacts,\r\n    location?: Location,\r\n}\r\n\r\ninterface Text extends MessageEntity {\r\n    body: string\r\n}\r\n\r\ninterface Image extends MessageEntity {\r\n    id: string\r\n    mime_type: string\r\n    file_extension: string,\r\n    caption: string\r\n}\r\n\r\ninterface Video extends MessageEntity {\r\n    id: string\r\n    mime_type: string,\r\n    file_extension: string,\r\n    caption: string\r\n}\r\n\r\ninterface Voice extends MessageEntity {\r\n    id: string,\r\n    mime_type: string,\r\n    file_extension: string\r\n}\r\n\r\ninterface Document extends MessageEntity {\r\n    id: string,\r\n    mime_type: string,\r\n    file_extension: string,\r\n    filename: string\r\n}\r\n\r\ninterface Contacts extends MessageEntity {\r\n    vcard: string\r\n}\r\n\r\ninterface Location extends MessageEntity {\r\n    link: string\r\n}\r\n","import Api from './api';\r\nimport { assertNotNull, assertPhone } from './Validations';\r\nimport {V1} from './v1-types'\r\n\r\nexport class Messages {\r\n\r\n    private readonly url = 'messages' \r\n\r\n    constructor(private readonly api : Api) {}\r\n\r\n    /**\r\n     * Send text message to private chat\r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param text // text message to send \r\n     */\r\n    async sendTextMessage(phoneNumber: string, text : string) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(text, 'parameter text must not be empty')\r\n        return this.api.post(this.url, {\r\n            to: phoneNumber,\r\n            type: \"text\",    \r\n            text: {\r\n                body: text\r\n            }    \r\n        })\r\n    }\r\n    \r\n    /**\r\n     * Send text message to group chat \r\n     * @param chatId Groupd id in format like \"00000000000-XXXXXXXXXX\". For example : \"79001234567-1581234048\"\r\n     * @param text // text message to send \r\n     */\r\n    async sendTextMessageToGroup(chatId: string, text : string) : Promise<V1.MessageResponse> {\r\n        assertNotNull(chatId, 'parameter chatId must not be empty')\r\n        assertNotNull(text, 'parameter text must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: \"group\",\r\n            to: chatId,\r\n            type:\"text\",    \r\n            text: {\r\n                body: text\r\n            }    \r\n        })\r\n    }\r\n\r\n    /**\r\n     * Send image. Before image have to be uploaded to server using method media.uploadMedia() \r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param mediaId id obtained from uploading image via method media.uploadMedia() \r\n     * @param caption title under image in WhatsApp\r\n     * @param recipient_type chat type. Can be individual or group\r\n     */\r\n    async sendImageById(phoneNumber: string, mediaId : string, caption? : string, recipient_type : V1.RecipientTypes = V1.RecipientTypes.Individual) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(mediaId, 'parameter mediaId must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: recipient_type,\r\n            to: phoneNumber,\r\n            type: \"image\",\r\n            image: {\r\n                id: mediaId,\r\n                caption: caption\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Send image by any url accessible from public zone of Internet\r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param link url\r\n     * @param caption title under image in WhatsApp\r\n     * @param recipient_type chat type. Can be individual or group\r\n     */\r\n    async sendImageByLink(phoneNumber: string, link : string, caption? : string, recipient_type : V1.RecipientTypes = V1.RecipientTypes.Individual) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(link, 'parameter link must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: recipient_type,\r\n            to: phoneNumber,\r\n            type: \"image\",\r\n            image: {\r\n                link: link,\r\n                caption: caption\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Send video. Before video have to be uploaded to server using method media.uploadMedia() \r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param mediaId id obtained from uploading video via method media.uploadMedia() \r\n     * @param recipient_type chat type. Can be individual or group\r\n     */\r\n    async sendVideoById(phoneNumber: string, mediaId : string, recipient_type : V1.RecipientTypes = V1.RecipientTypes.Individual) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(mediaId, 'parameter mediaId must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: recipient_type,\r\n            to: phoneNumber,\r\n            type: \"video\",\r\n            video: {\r\n                id: mediaId,\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Send video by any url accessible from public zone of Internet\r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param link url\r\n     * @param caption title under video in WhatsApp\r\n     * @param recipient_type chat type. Can be individual or group\r\n     */\r\n    async sendVideoByLink(phoneNumber: string, link : string, recipient_type : V1.RecipientTypes = V1.RecipientTypes.Individual) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(link, 'parameter link must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: recipient_type,\r\n            to: phoneNumber,\r\n            type: \"video\",\r\n            video: {\r\n                link: link,\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Send audio. Before audio have to be uploaded to server using method media.uploadMedia() \r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param mediaId id obtained from uploading audio via method media.uploadMedia() \r\n     * @param recipient_type chat type. Can be individual or group\r\n     */\r\n    async sendAudioById(phoneNumber: string, mediaId : string, recipient_type : V1.RecipientTypes = V1.RecipientTypes.Individual) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(mediaId, 'parameter mediaId must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: recipient_type,\r\n            to: phoneNumber,\r\n            type: \"audio\",\r\n            audio: {\r\n                id: mediaId,\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Send audio by any url accessible from public zone of Internet\r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param link url\r\n     * @param caption title under audio in WhatsApp\r\n     * @param recipient_type chat type. Can be individual or group\r\n     */\r\n    async sendAudioByLink(phoneNumber: string, link : string, recipient_type : V1.RecipientTypes = V1.RecipientTypes.Individual) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(link, 'parameter link must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: recipient_type,\r\n            to: phoneNumber,\r\n            type: \"audio\",\r\n            audio: {\r\n                link: link,\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Send document. Before document have to be uploaded to server using method media.uploadMedia() \r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param mediaId id obtained from uploading document via method media.uploadMedia() \r\n     * @param recipient_type chat type. Can be individual or group\r\n     */\r\n    async sendDocumentById(phoneNumber: string, mediaId : string, recipient_type : V1.RecipientTypes = V1.RecipientTypes.Individual) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(mediaId, 'parameter mediaId must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: recipient_type,\r\n            to: phoneNumber,\r\n            type: \"document\",\r\n            document: {\r\n                id: mediaId,\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Send document by any url accessible from public zone of Internet\r\n     * @param phoneNumber phone number, for example '79001234567'\r\n     * @param link url\r\n     * @param caption title under document in WhatsApp\r\n     * @param recipient_type chat type. Can be individual or group\r\n     */\r\n    async sendDocumentByLink(phoneNumber: string, link : string, recipient_type : V1.RecipientTypes = V1.RecipientTypes.Individual) : Promise<V1.MessageResponse> {\r\n        assertPhone(phoneNumber)\r\n        assertNotNull(link, 'parameter link must not be empty')\r\n        return this.api.post(this.url, {\r\n            recipient_type: recipient_type,\r\n            to: phoneNumber,\r\n            type: \"document\",\r\n            document: {\r\n                link: link,\r\n            }\r\n        })\r\n    }\r\n}","import Api from './api';\r\nimport { assertNotNull } from './Validations';\r\nimport {V1} from './v1-types'\r\n\r\nexport class Media {\r\n\r\n    private readonly url = 'media' \r\n\r\n    constructor(private readonly api : Api) {}\r\n\r\n    /**\r\n     * Upload binary data (images, documents etc) to the server. After uploading you can send media to WhatsApp using id of the uploaded data \r\n     * @param data binary data to upload\r\n     * @param fileExtension extension of upladed data that will be assign to media message in WhatsApp.\r\n     */\r\n    async uploadMedia(data: Buffer, fileExtension : string) : Promise<string> {\r\n        assertNotNull(data, 'parameter data must not be empty')\r\n        assertNotNull(fileExtension, 'parameter fileExtension must not be empty')\r\n        if (fileExtension.startsWith('.')) {\r\n            fileExtension = fileExtension.slice(1)\r\n        }\r\n        const response = await this.api.postMedia(this.url, data, fileExtension) as V1.MediaResponse\r\n        return response.media[0].id\r\n    }\r\n}","import Api from './api';\r\nimport { assertNotNull, assertObjectNotEmpty } from './Validations';\r\nimport {V1} from './v1-types'\r\n\r\nexport class Broadcasts {\r\n\r\n    private readonly url = 'broadcast' \r\n\r\n    constructor(private readonly api : Api) {}\r\n\r\n    /**\r\n     * Send broadcast message to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param text text message to send \r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastTextMessage(phoneNumbers: Array<string>, text : string, \r\n        regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(text, 'parameter text must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type: \"text\",\r\n            text: {\r\n                body: text\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    /**\r\n     * Send broadcast image to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param mediaId id obtained from uploading image via method media.uploadMedia() \r\n     * @param caption title under image in WhatsApp\r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastImageById(phoneNumbers: Array<string>, mediaId : string, caption? : string,\r\n        regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(mediaId, 'parameter mediaId must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type:  \"image\",\r\n            image: {\r\n                id: mediaId,\r\n                caption: caption\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        \r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    /**\r\n     * Send broadcast image to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param link url\r\n     * @param caption title under image in WhatsApp\r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastImageByLink(phoneNumbers: Array<string>, link : string, caption? : string,\r\n        regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(link, 'parameter mediaId must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type:  \"image\",\r\n            image: {\r\n                link: link,\r\n                caption: caption\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        \r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    /**\r\n     * Send broadcast video to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param mediaId id obtained from uploading video via method media.uploadMedia() \r\n     * @param caption title under video in WhatsApp\r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastVideoById(phoneNumbers: Array<string>, mediaId : string,\r\n        regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(mediaId, 'parameter mediaId must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type:  \"video\",\r\n            video: {\r\n                id: mediaId\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        \r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    /**\r\n     * Send broadcast video to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param link url\r\n     * @param caption title under video in WhatsApp\r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastVideoByLink(phoneNumbers: Array<string>, link : string,\r\n         regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(link, 'parameter mediaId must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type:  \"video\",\r\n            video: {\r\n                link: link\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        \r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    /**\r\n     * Send broadcast document to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param mediaId id obtained from uploading document via method media.uploadMedia() \r\n     * @param caption title under document in WhatsApp\r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastDocumentById(phoneNumbers: Array<string>, mediaId : string,\r\n        regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(mediaId, 'parameter mediaId must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type:  \"document\",\r\n            document: {\r\n                id: mediaId\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        \r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    /**\r\n     * Send broadcast document to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param link url\r\n     * @param caption title under document in WhatsApp\r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastDocumentByLink(phoneNumbers: Array<string>, link : string,\r\n         regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(link, 'parameter mediaId must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type:  \"document\",\r\n            document: {\r\n                link: link\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        \r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    /**\r\n     * Send broadcast audio to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param mediaId id obtained from uploading audio via method media.uploadMedia() \r\n     * @param caption title under audio in WhatsApp\r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastAudioById(phoneNumbers: Array<string>, mediaId : string,\r\n        regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(mediaId, 'parameter mediaId must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type:  \"audio\",\r\n            audio: {\r\n                id: mediaId\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        \r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    /**\r\n     * Send broadcast audio to several phone numbers. There must be at least 2 receivers\r\n     * @param phoneNumbers array of phones, for example ['79001234567', '79001234568']\r\n     * @param link url\r\n     * @param caption title under audio in WhatsApp\r\n     * @param regPeriod filter by registration period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param activePeriod filter for activity period for phones. Something like {\"from\": \"2020-01-01 00:00:00\", \"to\": \"2020-01-31 23:59:59\"}\r\n     * @param startAt date when to start broadcasting. If empty to begin immediately. Format like \"2020-01-01 00:00:00\" \r\n     */\r\n    async sendBroadcastAudioByLink(phoneNumbers: Array<string>, link : string,\r\n         regPeriod?: PeriodFilter, activePeriod?: PeriodFilter, startAt? : string) : Promise<V1.MessageResponse> {\r\n\r\n        assertObjectNotEmpty(phoneNumbers, 'parameter phoneNumbers must not be empty')\r\n        assertNotNull(link, 'parameter mediaId must not be empty')\r\n\r\n        const body : any = {\r\n            name: \"Broadcast from Green-API\",\r\n            to: this.toWaIds(phoneNumbers),\r\n            type:  \"audio\",\r\n            audio: {\r\n                link: link\r\n            }\r\n        }\r\n\r\n        if (regPeriod) {\r\n            body.period = regPeriod\r\n        }\r\n\r\n        if (activePeriod) {\r\n            body.active = activePeriod\r\n        }\r\n\r\n        \r\n        if (startAt) {\r\n            body.startAt = startAt\r\n        }\r\n\r\n        return this.api.post(this.url, body)\r\n    }\r\n\r\n    private toWaIds(phoneNumbers: Array<string>) {\r\n        if (phoneNumbers.length < 2) {\r\n            throw new Error('There are not enough phones to send broadcast. Must be at least 2')\r\n        }\r\n        return phoneNumbers.map(phone => { return {wa_id: phone}})\r\n    }\r\n}\r\n\r\nexport interface PeriodFilter {\r\n    from: string,\r\n    to: string\r\n}","import Api from './api';\r\nimport {V1} from './v1-types'\r\n\r\nexport class Notifications {\r\n\r\n    private readonly url = 'notifications' \r\n\r\n    constructor(private readonly api : Api) {}\r\n\r\n    /**\r\n     * Notifications include data about incoming messages, statues, sent messges. \r\n     * After receving notification it have to be deleted with the method deleteNotification() in order to receive the next notification\r\n     * Inner implementation uses long polling. Every method invokes loop that waits 20 seconds for the next message. \r\n     * If no messages arrive then the loop ends with the empty response.\r\n     */\r\n    async receiveNotification() : Promise<V1.NotificationResponse> {\r\n        return this.api.get(this.url)\r\n    }\r\n\r\n    /**\r\n     * Delete notification for remote server using receiptId\r\n     * @param receiptId message id get coming from notification\r\n     */\r\n    async deleteNotification(receiptId: number) : Promise<any> {\r\n        return this.api.delete(`${this.url}/${receiptId}`)\r\n    }\r\n}","import Api, { Options } from './api';\nimport { Messages } from './messages'\nimport { Media } from './media';\nimport { Broadcasts } from './broadcasts';\nimport { Notifications } from './notifications';\n\nexport default class WhatsAppApi {\n    public readonly messages: Messages\n    public readonly media: Media\n    public readonly broadcasts: Broadcasts\n    public readonly notifications: Notifications\n\n    constructor(token: string, options?: Options) {\n        const api = new Api(token, options)\n        this.messages = new Messages(api)\n        this.media = new Media(api)\n        this.broadcasts = new Broadcasts(api)\n        this.notifications = new Notifications(api)\n    }\n}\n\nmodule.exports = Object.assign(WhatsAppApi, {\n    default: WhatsAppApi,\n})"],"names":["assertNotNull","val","errorMsg","Error","assertObjectNotEmpty","obj","isObjectEmpty","Object","keys","length","constructor","assertPhone","test","assertNumeric","DEFAULT_OPTIONS","apiRoot","mediaRoot","Api","token","options","headers","this","assertApiToken","url","response","axios","get","DEFAULT_AXIOS_CFG","data","ex","processError","delete","post","ext","config","method","isAxiosError","JSON","stringify","V1","RecipientTypes","Messages","api","phoneNumber","text","to","type","body","chatId","recipient_type","mediaId","caption","Individual","image","id","link","video","audio","document","Media","fileExtension","startsWith","slice","postMedia","media","Broadcasts","phoneNumbers","regPeriod","activePeriod","startAt","name","toWaIds","period","active","map","phone","wa_id","Notifications","receiptId","WhatsAppApi","messages","broadcasts","notifications","module","exports","assign","default"],"mappings":"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"}